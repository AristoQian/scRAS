scores<-function(feature.mat, anchor.frac = 0.15, n.cores = 1,verbose = T, K=30){
  if(mode(feature.mat)=="list"){
    feature.mat<-as.matrix(feature.mat)
  }
  #the index of uniformly sampled cells
  uniform.sample.index<- sample(1:dim(feature.mat)[1],size = floor(anchor.frac*dim(feature.mat)[1]),replace = F)
  # Rcpp::sourceCpp(code='
  # #include <Rcpp.h>
  # #include <math.h>
  # using namespace Rcpp;
  # using namespace std;
  # // [[Rcpp::export]]
  # NumericMatrix distance_cpp(int x, int cell_num, NumericMatrix red_dat) {
  #   NumericMatrix distance(cell_num, 1);
  #   int feature_num = red_dat.ncol();
  #   int i = 0;
  #   for(i=0; i<cell_num; i++){
  #     if(i == x-1){
  #       double temp = 0;
  #       distance(i,0) = temp;
  #     }
  #     else{
  #       double temp = 0;
  #       int j = 0;
  #       for(j = 0; j < feature_num; j++){
  #         double diff = red_dat(x-1,j)-red_dat(i,j);
  #         double add_term = pow(diff,2);
  #         temp+=add_term;
  #       }
  #       double temp2 = 0;
  #       temp2 = sqrt(temp);
  #       distance(i,0) = temp2;
  #     }
  #   }
  # 
  #   return distance;
  # }')
  Rcpp::sourceCpp("../distance_cpp.cpp")
  #distance matrix between anchors and other cells
  # distance.cell2remain<-function(x,cell.num,red.dat){
  #   as.matrix(sapply(1:cell.num, function(y){
  #     if(x!=y){return(norm(as.matrix(red.dat[,x]-red.dat[,y]),"F"))}
  #     else{return(0)}
  #   }))
  # }
  if(verbose == T){print("Constructing affinity matrix")}
  # computing affinity matrix
  H<-sapply(uniform.sample.index,function(x){
    distance_cpp(x = x, red_dat = t(feature.mat), cell_num = dim(feature.mat)[1])
  })
  
  # computing CSD
  if(verbose ==T){print("Computing the cell state deviations considering the distances from majority cells")}
  
  norm.H<-diag(1/apply(H,1,sum))%*%H
  W =norm.H%*%t(H)
  L<-diag(apply(W,1,sum)) - W
  scores<-sapply(1:dim(L)[1], function(x){L[x,x]})
  scores<-(-1)*scores
  scores<-(scores-min(scores))/(max(scores)-min(scores))
  
  # computing CAS
  if(verbose==T){print("Computing anomalous scores")}
  # W = H%*%t(H)
  norm2.H<-diag(1/apply(H,1,norm, type = "2"))%*%H
  W = norm2.H%*%t(norm2.H)
  cell.specific.knearest.locs<-t(parallel::mcmapply(function(x){
    return(order(W[x,],decreasing = T)[2:(K+1)])
  }, 1:dim(feature.mat)[1], mc.cores = n.cores))
  scores.knn<-parallel::mcmapply(function(x){
    mean(scores[cell.specific.knearest.locs[x,]])
  },1:length(scores),mc.cores = n.cores)
  anomalous.scores<-abs(scores-scores.knn)
  anomalous.scores<-(anomalous.scores-min(anomalous.scores))/(max(anomalous.scores)-min(anomalous.scores))
  
  return(list(CSD = scores, CAS = anomalous.scores))
  
}
