rare.cell.scores<-function(feature.mat, anchor.frac = 0.15, local.sparse = NULL, n.cores = 1,verbose = T, K=30, return = "CSD"){
  if(mode(feature.mat)=="list"){
    feature.mat<-as.matrix(feature.mat)
  }
  if(is.null(local.sparse)!=T && is.numeric(local.sparse)==F){
    stop("local.sparse must be an integer smaller than the number of the number of cells minus one")
  }
  if(return!="CSD"){
    if(return!="Anomalous"){
      stop("return must be 'CSD' or 'Anomalous'")
    }
  }
  #the index of uniformly sampled cells
  uniform.sample.index<- sample(1:dim(feature.mat)[1],size = floor(anchor.frac*dim(feature.mat)[1]),replace = F)
  
  #distance matrix between anchors and other cells
  distance.cell2remain<-function(x,cell.num,red.dat){
    as.matrix(sapply(1:cell.num, function(y){
      if(x!=y){return(norm(as.matrix(red.dat[,x]-red.dat[,y]),"F"))}
      else{return(0)}
    }))
  }
  
  
  if(verbose == T){print("Constructing affinity matrix")}
  
  H<-sapply(uniform.sample.index,function(x){
    distance.cell2remain(x = x, red.dat = t(feature.mat), cell.num = dim(feature.mat)[1])
  })
  
  #the hausdorff distance between sampled points and retained points
  cell.wise.min.distance<-apply(H,1,function(x){
    sort.x<-sort(x)
    if(sort.x[1]==0){
      return(sort.x[2])
    }
    else{
      return(sort.x[2])
    }
  })
  if(is.null(local.sparse)){
    # B<-H
    #D.H<-stats::quantile(cell.wise.min.distance,alpha)
    # D.H<-apply(B,1,max)
    #the bipartite based on Hausdorff distance and K-NN
    #B[B>D.H]<-0
    
    
    # Knn.dist.list<-lapply(1:dim(B)[1],function(x){
    #   if(length(which(B[x,]>0))==0){
    #     return(1)
    #   }
    #   else{
    #     dist.anc<-B[x,which(B[x,]>0)]
    #     sum.dist.anc<-sum(dist.anc)
    #     len.dist.anc<-length(which(B[x,]>0))
    #     return(as.vector((D.H[x]-dist.anc)/(len.dist.anc*D.H[x]-sum(dist.anc))))
    #   }
    #   
    # })
    # for(i in 1:dim(B)[1]){
    #   if(length(which(B[i,]>0))==0){
    #     B[i,which(H[i,]==min(H[i,]))]<- 1
    #   }
    #   else{
    #     B[i,which(B[i,]>0)]<-Knn.dist.list[[i]]
    #   }
    #   
    # }
    
    # print("Calculating rare cell score for each cell")
    # #Laplacian, Degree matrix
    # Lambda <- diag(apply(B,2,sum))[which(apply(B,2,sum) != 0),which(apply(B,2,sum) != 0)]
    # W <- B[,which(apply(B,2,sum) != 0)]%*%t(B[,which(apply(B,2,sum) != 0)])
    # L <- diag(apply(W,1,sum)) - W
    # 
    # #compute the rareness score of each cell
    # scores<-sapply(1:dim(L)[1], function(x){L[x,x]})
    # scores<-(-1)*(scores-min(scores))/(max(scores)-min(scores))
    if(verbose ==T){print("Computing the rareness scores considering the distances from majority cells")}
    
    norm.H<-diag(1/apply(H,1,sum))%*%H
    W =norm.H%*%t(H)
    L<-diag(apply(W,1,sum)) - W
    scores<-sapply(1:dim(L)[1], function(x){L[x,x]})
    scores<-(-1)*scores
    scores<-(scores-min(scores))/(max(scores)-min(scores))
  }
  else{
    if(verbose ==T){print("Computing the rareness scores considering the local sparsity of data points of cells")}
    
    dist.mat<-parallel::mcmapply(function(x){
      distance.cell2remain(x = x, red.dat = t(feature.mat), cell.num = dim(feature.mat)[1])
    }, 1:dim(feature.mat)[1], mc.cores = n.cores)
    cell.specific.knearest.locs<-t(parallel::mcmapply(function(x){
      return(order(dist.mat[x,])[1:local.sparse])
    }, 1:dim(feature.mat)[1], mc.cores = n.cores))
    scores<-parallel::mcmapply(function(x){
      knearest.locs<-as.vector(cell.specific.knearest.locs[x,])
      h<-H[x,]
      normalized.h<-H[x,]/sum(H[x,])
      h<-matrix(normalized.h,ncol = dim(H)[2])
      vec.sum.nearest.cells<-matrix(0,ncol = dim(H)[2])
      for(i in knearest.locs){
        if(i!=x){
          vec.sum.nearest.cells<-vec.sum.nearest.cells + H[i,]
        }
      }
      sum.vec.sum.nearest.cells<-sum(vec.sum.nearest.cells)
      edges.from.nearest.cells<-sapply(knearest.locs,function(y){
        if(y!=x){
          return(h%*%matrix(H[y,],nrow = dim(H)[2]))
        }
        else{
          return(0)
        }
      })
      return(sum(edges.from.nearest.cells)/sum.vec.sum.nearest.cells)
      
    }, 1:dim(feature.mat)[1], mc.cores = n.cores)
    scores<-(-1)*scores
    scores<-(scores-min(scores))/(max(scores)-min(scores))
  }
  if(verbose==T){print("Computing anomalous scores")}
  # dist.mat<-parallel::mcmapply(function(x){
  #   distance.cell2remain(x = x, red.dat = t(feature.mat), cell.num = dim(feature.mat)[1])
  # }, 1:dim(feature.mat)[1], mc.cores = n.cores)
  W = H%*%t(H)
  cell.specific.knearest.locs<-t(parallel::mcmapply(function(x){
    return(order(W[x,],decreasing = T)[2:(K+1)])
  }, 1:dim(feature.mat)[1], mc.cores = n.cores))
  scores.knn<-parallel::mcmapply(function(x){
    mean(scores[cell.specific.knearest.locs[x,]])
  },1:length(scores),mc.cores = n.cores)
  anomalous.scores<-abs(scores-scores.knn)
  anomalous.scores<-(anomalous.scores-min(anomalous.scores))/(max(anomalous.scores)-min(anomalous.scores))
  if(return=="CSD"){return(scores)}
  if(return=="Anomalous"){return(anomalous.scores)}
}
